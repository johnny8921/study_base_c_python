### 2. Программирование на С. 
#### Теория
- Введение в С. 
- Синтаксис и семантика С.
- Функции в С.
- Структуры и массивы. 
- Указатели и работа с ними. 
#### Практика 
- Запуск первой программы. Написание простейших программ АСУ ТП.

### Введение в С.
**Кто знает C?**

**Что такое Си?** 


**Си - компилируемый статически типизированный язык программирования общего назначения, разработанный в 1969—1973 годах сотрудником Bell Labs Деннисом Ритчи как развитие языка Би.**

Попробуем разобраться что тут написано:

С названием понятно. Разрабы не обладают дикой фантазией поэтому именовали язык подряд ))))

**Компилированный** — означает, что код сначала преобразуется в бинарный файл компилятором с машинным кодом, а дальше уже запускается на машиине.
Это означает, что у вас должен быть компилятор под каждую машину на которой вы планируете это запустить. Это ОГРОМНЫЙ геморрой всех программистов на С. У меня например стоит порядка 5-6 компиляторов для разных типов процессоров. Однако, при этих сложностях мы получаем самую высокую производительность. Ваш код уже преобразован в машинный и работает с максимальной скоростью. Есть еще быстрее — Ассемблер, но писать на нем — это отдельное поражение мозга. Я использую ассемблер только как инструмент, что бы посмотреть что программа делает не так.
Статически — обозначает, что вся память в программе выделена статически. Все переменные четко раскиданы по памяти и не могут занимать больше. В проектах на C на микроконтроллерах компилятор пишет в конце сколько занято какого вида памяти. При написании на языке C я смело оставляю 0 свободных байт ОЗУ. Потому что выделение в процессе работы случайно не произойдет. Вся пямять выделяется при запуске программы сразу. 

**Типизированный** — означает, что каждая переменная имеет четкий размер определенный еще до компиляции. С одной стороны это головная боль с 10 типа числовых данных, а еще компиляторы их по разному выделяют. А еще есть дерективы компилятору строго указывающие размер в независимости от типа ядра. Опять головняк, но применение таких типов дает там четкое выделение точного объема памяти и сокращение необходимого объема памяти. 
Эти особенности разработки и являются и плюсами и минусами этого языка. 
У языка С есть стандарты языка. Для С — С99. Не сложно догадаться, что это стандарт от 99 года. Тем не менее он абсолютно жив сейчас и придерживаясь его написано просто огромное количество программ.

### Синтаксис
1. **Структура программы**:
   - Программа на языке C состоит из одной или нескольких функций.
   - Главная функция `main()` является точкой входа в программу.

2. **Типы данных**:
   - Основные типы данных: `int`, `float`, `double`, `char`, `void`.
   - Структуры данных: массивы, структуры, указатели.

3. **Операторы**:
   - Арифметические операторы: `+`, `-`, `*`, `/`, `%`.
   - Логические операторы: `&&`, `||`, `!`.
   - Условные операторы: `if`, `else`, `switch`.
   - Циклы: `for`, `while`, `do-while`.

4. **Функции**:
   - Функции могут принимать аргументы и возвращать значения.
   - Использование библиотечных функций (например, `printf()`, `scanf()`).

5. **Указатели**:
   - Указатели используются для работы с адресами памяти.
   - Операции с указателями: `&` (адрес), `*` (декремент).

6. **Массивы**:
   - Массивы фиксированного размера.
   - Доступ к элементам массива через индексацию.

7. **Структуры**:
   - Структуры позволяют объединять данные разных типов.
   - Обращение к полям структур через точку (`.`) или стрелку (`->`).

### Семантика
1. **Значения и переменные**:
   - Переменные хранят значения определенного типа.
   - Значения могут быть присвоены переменным с помощью оператора присваивания (`=`).

2. **Выражения**:
   - Выражения состоят из операндов и операторов.
   - Результат выражения может быть использован в других выражениях или присвоен переменной.

3. **Управление потоком выполнения**:
   - Условные конструкции (`if`, `else`) изменяют порядок выполнения кода в зависимости от условий.
   - Циклы (`for`, `while`, `do-while`) повторяют блок кода до тех пор, пока условие истинно.

4. **Функции**:
   - Функции выполняют определенные задачи и могут возвращать результат.
   - Параметры функций передаются по значению или по ссылке (через указатели).

5. **Область видимости**:
   - Переменные имеют локальную область видимости внутри функции.
   - Глобальные переменные доступны во всей программе.

6. **Побочные эффекты**:
   - Некоторые операции могут иметь побочные эффекты, например, модификация глобальных переменных.


Конечно! Вот примеры функций с названиями на английском языке:


### Массивы

Массивы в C — это коллекции элементов одного типа, расположенных в памяти подряд.

#### Определение массива
```c
int numbers[5] = {1, 2, 3, 4, 5};
```

#### Использование массива
```c
void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};
    print_array(numbers, 5);
    return 0;
}
```

#### Указатели и массивы
В C массивы часто рассматриваются как указатели. Например:
```c
int numbers[5] = {1, 2, 3, 4, 5};
int *ptr = numbers;
printf("%d\n", *ptr);  // Выведет 1
```

#### Двумерные массивы
Двумерные массивы используются для представления таблиц или матриц.
```c
int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

void print_matrix(int mat[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", mat[i][j]);
        }
        printf("\n");
    }
}

int main() {
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    print_matrix(matrix, 3);
    return 0;
}
```

### Функция
Функция в C — это блок кода, который выполняет определенную задачу. Она может принимать входные параметры и возвращать результат.

**Синтаксис:**
```c
return_type function_name(parameters) {
    // body of the function
    return value;
}
```

Пример:
```c
int sum(int a, int b) {
    return a + b;
}
```

#### Параметры функции
Функции могут принимать параметры, которые передаются при вызове функции.

- **Positional parameters**: Parameters are passed in order.
- **Types of parameters**: Can be various data types (e.g., `int`, `float`, `char`).

Пример:
```c
void greeting(char *name) {
    printf("Hello, %s!\n", name);
}
```

#### Возвращаемые значения
Функции могут возвращать значения различных типов. Если функция не возвращает значение, ее тип указывается как `void`.

Пример:
```c
void no_return() {
    printf("This function does not return anything.\n");
}
```

#### Вызов функции
Функции вызываются с помощью их имени и передачи необходимых аргументов.

Пример:
```c
int main() {
    int x = 5, y = 10;
    int result = sum(x, y);
    printf("Sum: %d\n", result);
    return 0;
}
```

#### Передача значений и ссылок
- **Passing by value**: A copy of the value is passed to the function.
- **Passing by reference**: The address of the variable is passed through a pointer.

Пример передачи по ссылке:
```c
void increment(int *x) {
    (*x)++;
}

int main() {
    int num = 5;
    increment(&num);
    printf("Number after increment: %d\n", num);
    return 0;
}
```

#### Рекурсия
Функции могут вызывать сами себя, что называется рекурсией. Это полезно для решения задач, которые можно разбить на более простые подзадачи.

Пример:
```c
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

#### Библиотечные функции
C предоставляет множество библиотечных функций, которые можно использовать в программах. Например, `printf()`, `scanf()`, `strlen()` и другие.

Пример использования `printf()`:
```c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

#### Локальные и глобальные переменные
- **Локальные переменные**: Объявлены внутри функции и доступны только внутри этой функции.
- **Глобальные переменные**: Объявлены вне всех функций и доступны во всей программе.

Пример:
```c
int global_variable = 10;

void change_global() {
    global_variable++;
}

int main() {
    change_global();
    printf("Global variable: %d\n", global_variable);
    return 0;
}
```
### Структуры

Структуры в C позволяют объединять данные различных типов в один логический блок. Это полезно для организации сложных данных, таких как записи о людях, автомобилях и т.д.

#### Определение структуры
```c
struct Person {
    char name[50];
    int age;
    float height;
};
```

#### Использование структуры
```c
struct Person person1 = {"John Doe", 30, 1.80};

void print_person(struct Person p) {
    printf("Name: %s\nAge: %d\nHeight: %.2f\n", p.name, p.age, p.height);
}

int main() {
    struct Person person1 = {"John Doe", 30, 1.80};
    print_person(person1);
    return 0;
}
```

#### Указатели на структуры
```c
struct Person *person_ptr = &person1;
printf("Name: %s\n", (*person_ptr).name);
```


Такс… Начнем как и любые программисты с написания Hello World.

Написать HelloWorld для windows

Что такое структура? 
Давайте Поставим задачу: У нас есть бочка с водой к ней подключен нагреватель для поддержания теплой воды. Мы пишем программу управления этим ТЭНом. У нас есть сигнал на управление тэном, показатель текущей температуры и уставка до которой нужно нагреть. Так же добавим в простом виде гистерезис для регулирования 

В общем виде программа будет видеть так: 
Описать программу для управления одним тэном

А теперь к нам пришел заказчик и хочет сделать управление на 2 бочки одним контроллером. 
Хорошо. Добавим. Решим прямо в лоб:
Добавить код программы с дублированием переменных и двойным объемом кода.

Написали. Вроде бы лучше.
Снова пришел заказчик, говорит, что у него есть заказ на 4-х канальный контроллер. 

Решать задачу в лоб уже сложнее ))) 
Превращаем каждую переменную в массив. Управляющая программа выполняется в цикле. Куча переменных с их индексами.

Все здорово, но вот заказчик пришел и говорит, что надо добавить еще несколько параметров. И мы начинаем добавлять несколько массивов. По попути еще криво их именуем и пропускаем, и/или путаем местами. 

Кромешный АД!!!

Для работы с данными в С используются структуры. 
Удобный иснтрумент для хранения данных. Ключевой особенностью в Си является созлдание массивов структур.

Давайте напишем структуру для нашего нагревателя

струтура здесь долждна быть

Теперь перепишем код для одного нагревателя

исправленный код для одного

А для двух?

Исправленный код для двух
а для тысячи? Просто меняем размерность нашего массива. 
А давайте добавим новое поле: время старта для каджого поля?
Добавляем поле

Таким образом вы видите какой это мощный механизм хранения и работы с данными.


Что такое указатель? 
Написать

Линковка?
А надо ли
Компилятор?
А надо ли


ФИО, короткая вводная обо мне

- Будем изучать основы программирования на МК Cortex M0-M4, а именно STMF030xxx и ESP32.
- Рассмотрим как устроена память контроллеров и как их программировать. Что можно делать и что не рекомендуется.
- Будем изучать С и Python
- Так же будем работать с git и gitFlow
- Работать мы будем в cubeIDE И pyCharm community.

Пары будем делить на две части: теория и практика, или только практика

Сдача практик через репозитории на Гите. Кидаем ссылку, я просматриваю и выставляю вам оценки.
Для работы с гитом я использую любой продукт ов jetBrains pycharm. От  вас не требую этого правила, но это лучшее чт о было придумано для работы с ним в IDE

Примечание: 
	Разработка проектов для микроконтроллеров в jetBrains пока тяжела и не даёт полного контроля за контроллерами stm32 и mm32

### Теория
#### Стандарты программирования
Хороший стиль программирования: если ты читаешь код через неделю и понимаешь о чем он. 
Вставляем ссылку на книжку Мартина и дальше описываем почему он идет нахрен с микроконтроллерах. 

В каждом вашем проекте Вы пишете программу для себя. Не для друзей, не для коллег и не для сообщества. Вы пишите код для себя. И поэтому код нужно писать так, что бы ты понял как он работает без долгих терзаний мозга. 
Плохой стиль: 
Привести плохое именование, кривые дефайны
Если вы работаете в команде, то вам нужно договориться о том как вы именуете переменные, какие отступы и другой формат-стайл policy. В целом для языков уже есть базовые policy и вы можете придерживаться следующих правил:
1) Именование переменных должно быть читаемым
2) Избегать функций длиннее 30+ строк.
3) переиспользовать ваш код (организуя функции), если у вас одни и те же действия используются несколько раз. Так вы не выстрелите себе в ногу, когда нужно будет поменять общее поведение в программе.
4) Не переусердствовать с п2 и п3, если действия похожи, но делают координально разные вещи, и организация функции требует введения особых аргументов функции, то от такого решщения проще отказаться, чем вспоминать через пару недель а что же это за флаги такие
5) Разделять программу на файлы и использовать инкапсуляцию.

#### Система контроля версий. Git, GitFlow.
При работе в команде вам однозначно понадобится git. Так же и gitFlow.

**Что же такое git?**

**Git - это система контроля версий придуманная Линусом Торвальдсом для совместной работы программистов.**

Основные принципы работы с Git:
1. Локальный репозиторий:
   - Git работает с локальными репозиториями, которые хранятся на вашем компьютере. Это позволяет работать автономно без необходимости подключения к интернету.
2. Снимки состояния:
   - Git сохраняет снимки состояния проекта в виде коммитов. Каждый коммит представляет собой полную запись всех файлов в репозитории на момент создания коммита.
3. История изменений:
   - Git отслеживает историю изменений в проекте. Вы можете легко вернуться к любому предыдущему состоянию проекта, используя команды для просмотра и восстановления истории.
4. Ветвление и слияние:
   - Ветвление (branching) позволяет создавать новые ветки для разработки новых функций или исправлений без влияния на основную ветку. Слияние (merging) используется для объединения изменений из одной ветки в другую.
5. Распределенная система:
   - Git является распределенной системой управления версиями. Это означает, что каждый участник имеет полную копию репозитория, включая всю историю изменений. Это обеспечивает высокую надежность и скорость работы.
6. Отмена изменений:
   - Git предоставляет возможность отменять изменения на различных уровнях: отмена последнего коммита, отмена неотправленных изменений и т.д.
7. Работа с удаленным репозиторием:
   - Git позволяет работать с удаленными репозиториями, такими как GitHub, GitLab или Bitbucket. Вы можете отправлять свои изменения на удаленный репозиторий и получать последние обновления из него.
8. Конфликты при слиянии:
   - При слиянии веток могут возникать конфликты, если одни и те же строки были изменены в разных ветках. Git автоматически выявляет эти конфликты, и вам нужно будет их разрешить вручную.
9. Теги:
   - Теги (tags) используются для маркирования важных точек в истории проекта, таких как релизы. Они позволяют легко ссылаться на конкретные версии проекта.
10. Эффективное использование команд:
    - Git предоставляет множество команд для выполнения различных операций. Освоение базовых команд (git add, git commit, git push, git pull, git branch, git merge) позволит эффективно управлять проектом.

## TODO: Добавить QR для git и Пушкин 
https://habr.com/ru/companies/skillbox/articles/413161/


Теперь мы поняли что такое GIT. Как с ним работать мы поймем дальше на практических занятиях.

Теперь нам нужно разобраться со второй частью.

**GitFlow**

В Своей работе программисты почти всегда работают в командах и когда продукт компании выходит за пределы hello world очень важно расставлять вехи. Веха - Это жизненный этап программного обеспечения который гарантирует какое то работающее состояние программы.  

В Git есть ветки (Branch), которые пользователь в принципе может именовать как ему захочется. 
GitFlow Предлагает нам вести несколько веток проектов для разделения состояния программного кода. 

Первая ветка — master. Это базовая ветка со стабильно работающим кодом. В эту ветку программист заливает уже отлаженный код и именно сюда приходят пользователи для скачивания вашего кода.
Вторая ветка — develop. Это ветка в которой сейчас ведется автивная разработка. Код здесь должен запускаться, но не обязан работать и обладать полным функционалом. 
Ветки с индексом feature/. Когда программист хочет написать новую фишку программы от создает фичу. Фича наследуется от develop и позволяет программисту не мешая другим разрабам пилить новую функцию и не мешать другим. После окончания работы над фичей программист делает PullRequest  и вливает все свои изменения в develop. Если во время пулреквеста есть конфликты, то программист их решает и устраняет. 

Промежуточно на ветке develop могут проходить тестирования и тестировщих проверяет работу всей программы на предмет падения программы в результате затрагивания каких либо частей программы. Если такое произошло, то появляется issue для устранения бага. Программист которому поручают решение багов созхдает ветку с индексом bugfix в которой он решает возникший вопрос и делает пулреквест в девелоп с подтвержением на исправление бага. Тестирвоание повторяется. 

После того как программисты сделали 2, 3,5, 10, 100 своих фич, отладили все баги и они удовлетворили заказчика ПО по функциям они делают pullRequest в master. На этом этапе код уже должен быть стабильным и иметь либо список knowBugs или не иметь известных разрабам багов.
Обычно при заливании в мастер на многих серверах запускается автоматическое развертывание системы на боевые сервера. 
Поэтому важно понимать, к каким действиям приведут ваши pullRequest.

Если в работе программы у конечного пользователя выявился критический баг, устранение которого не терпит отлагательства, то от ветки master запускается ветка /hotfix, в которой устраняются критические баги. После их устранения — ветка сливается сразу в мастер.
 
Если баг не критичный, то создается issue и в порядке разработки бага устраняется программистами и готовится к релизам в рабочем порядке

Итак резюмируем:
- в master стабильный боевой код
- в develop код готовый к следующим релизам или тестированию
- в /feature/моя_фича я работаю над новыми функциями программы
- в /bugfix/мой_баг я исправляю известные баги программы
- в /hotfix/мой_просак я исправляю критические баги, которые нужно исправить немедленно.
- Вот в целом и все что нужно знать о GitFlow.  За мои 10 лет разработки данный принцип разработки показался для меня самым удобным.
 
Пока знаний по инструментам хватит. Начнем наше погружение.

### Практика
- Установка IDE для разработки ПО на С и Python.

